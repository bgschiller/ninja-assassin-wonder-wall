\documentclass[12pt,x11names, rgb]{article}



    \usepackage{clrscode3e}
    \usepackage{hyperref}
    \usepackage[parfill]{parskip}
    \usepackage{amsmath,amsthm,amssymb}
    \usepackage{latexsym} %gives nice \leadsto
    \newtheorem*{lem}{Lemma}
    \newtheorem*{thm}{Theorem}
    \newtheorem*{definition}{Definition}

    \DeclareMathOperator{\w}{w}
    \DeclareMathOperator{\n}{n}
    \DeclareMathOperator{\pairs}{pairs}
    \usepackage{moreverb}

    \usepackage{multicol}
    \usepackage{pstricks}
    \usepackage{auto-pst-pdf}
    \usepackage[margin=1.5in]{geometry}
    \usepackage{moreverb}
    \usepackage{listings}
    \usepackage{color}

    %\usepackage[x11names, rgb]{xcolor}
    \usepackage[utf8]{inputenc}
    \usepackage{tikz}
    \usetikzlibrary{snakes,arrows,shapes}

    \definecolor{mygreen}{rgb}{0,0.5,0}
    \definecolor{mygray}{rgb}{0.5,0.5,0.5}
    \definecolor{mymauve}{rgb}{0.58,0,0.82}


    \title{The Ninja Assassin Wonderwall Game}
    \author{Brian Schiller \\ { advised by Dr. Tilmann Glimm}}
    \date{Spring 2013}


\begin{document}
\begin{center}
{\LARGE The Ninja Assassin Wonderwall Game }

\large
\vspace{12pt}
Brian Schiller\\
advised by Dr. Tilmann Glimm
\vspace{6pt}

Spring 2013
\end{center}
%\maketitle

In this summer camp game, each of $n$ players chooses one person to be their Ninja Assassin and another to be their Wonderwall. When the game starts, each player runs to try to keep their Wonderwall on the line between themself and their Ninja Assassin. 

We create an algorithm, based on finding cycles in directed graphs, that creates a configuration satisfying every player's constraints or says that no such configuration exists. We also use a computer model to estimate the probability that a given game has such a configuration.


\tableofcontents

\section{Introduction}
\label{sec:introduction}
    Ninja Assassin Wonderwall is a game played at summer camps, sometimes under the name `Eclipse'. It is played with as few as 4 players, though it is better with ten or more. To play, each player chooses two other players (without indicating their choices), one to be their ninja assassin and the other to be their wonderwall. When the game starts, every player tries to keep their wonderwall between themself and their ninja assassin.

    Camp counselors who organize the game can usually expect it to last until campers grow bored or it is called off. But occasionally the running players will slow down... and stop. Every player finds themselves on the safe side of their wonderwall, protected from their ninja assassin. We call this scenario a solution, which will be more precisely defined in the next section.

    In the small example below, every player is in a position that satisfies their constraints--they are on a line with their ninja assassin and wonderwall with the wonderwall in the middle. The players' choices are displayed in a relationship table at right. Each row of the table shows a player, that player's wonderwall, and that player's ninja assassin.

    \begin{center} %6 player example game
        \begin{multicols}{2}
            \begin{pspicture}(0,0)(10,10)
                \qdisk(0,1){2pt}
                \uput[u](0,1){C}

                \qdisk(-0.4,2){2pt}
                \uput[u](-0.4,2){E}

                \qdisk(1,2){2pt}
                \uput[u](1,2){B}

                \qdisk(2,3){2pt}
                \uput[u](2,3){A}

                \qdisk(2.4,2){2pt}
                \uput[u](2.4,2){D}

                \qdisk(3.5,2){2pt}
                \uput[u](3.5,2){F}
            \end{pspicture}

            \columnbreak

            \begin{tabular}{l | c | c}
                $p$ & $\w(p)$ & $\n(p)$ \\
                \hline
                A &  B& C\\
                B &  D& F\\
                C &  B& A\\
                D &  B& E\\
                E &  D& F\\
                F &  D& B
            \end{tabular}
         \end{multicols}
    \end{center}

    Looking at that solution, it seems like we could grab players $A$ and $C$ and pivot them around $B$, putting all the players on a line. But can we always reduce a solution to a single dimension? It seems like the extra freedom in higher dimensions might allow new solutions that don't appear on the real line.

    In fact, we will see in section~\ref{sec:reduction_to_one} that if a game has a solution in $\mathbb{R}^n$ it must also have a solution on the real line. This means that campers need not dig holes and climb trees in order to produce a solution. The result also means that in searching for solutions we can restrict our search to linear orderings of the players.
\newpage
    Not every game has a solution. Below are two four-player games, one with a solution and one without.

    \begin{center} %4 player games
        \begin{multicols}{2} %solved game
            \begin{pspicture}(-5,-5)(5,5)
                \qdisk(0,0){2pt}
                \uput[u](0,0){A}

                \qdisk(1,0){2pt}
                \uput[u](1,0){B}

                \qdisk(2,0){2pt}
                \uput[u](2,0){C}

                \qdisk(3,0){2pt}
                \uput[u](3,0){D}
            \end{pspicture} 

            \columnbreak
            
            \begin{tabular}{ l | c | c}
                 $p$ & $\w(p)$ & $\n(p)$ \\
                 \hline
                  A &  B& C\\
                  B &  C& D\\
                  C &  B& A\\
                  D &  B& A\\
            \end{tabular}
        \end{multicols}
        \vspace{24pt}
        \begin{multicols}{2} %unsolvable game
            \begin{pspicture}(-5,-5)(5,5)
                \qdisk(-1,0){2pt}
                \uput[u](-1,0){A}

                \qdisk(1,0){2pt}
                \uput[u](1,0){C}

                \qdisk(0,1){2pt}
                \uput[u](0,1){B}

                \qdisk(0,-1){2pt}
                \uput[u](0,-1){D}
            \end{pspicture}

            \columnbreak
            
            \begin{tabular}{l | c | c}
                $p$ & $\w(p)$ & $\n(p)$ \\
                \hline
                A & B& C\\
                B & D& A\\
                C & B& A\\
                D & B& A
            \end{tabular}
        \end{multicols}
    \end{center}
    How can we tell from the relationship table whether or not a game has a solution? Since it is sufficient to search the orderings of players, we could simply try every permutation of the players. However, this proves to be too computationally expensive. In section~\ref{sec:cnf_sat} we will give a recipe for transforming an instance of a ninja assassin wonderwall game into an instance of a Boolean Satisfiability problem. We will explore another algorithm in section~\ref{sec:algorithm}, based on finding cycles in directed graphs.

    Finally, in section~\ref{sec:prob}, we apply this algorithm to a random sample of games in order to estimate the proportion that are solvable, and how that proportion changes with the number of players.

\section{Reduction to one dimension}
\label{sec:reduction_to_one}

    Before we can reason precisely about Ninja Assassin Wonderwall games, we need a few definitions.

    \begin{definition}
    A \emph{Ninja Assassin Wonderwall problem} is a set $P$ together with two functions $\w:P\to P, \quad \n: P\to P$ that satisfy $\w(p) \neq p, \n(p) \neq p, \text{ and } \w(p) \neq \n(p)$ for all $p \in P$.
    \end{definition}

    Here, $\w(p)$ and $\n(p)$ represent the wonderwall and ninja assassin, respectively, of a player $p$. The restrictions on the functions ensure that no player may choose themselves as either role or choose the same person for both roles. 
	
	\vspace{12pt}
    \begin{definition}
    A \emph{solution} to a Ninja Assassin Wonderwall problem is a function $S: P\to \mathbb{R}^{n}$ such that:
        \begin{enumerate}
        \item $S$ is one-to-one (two players may not occupy the same space)
        \item For each $p \in P$, $S(\w(p))$ lies on the line segment between $S(p)$ and $S(\n(p))$.
        \end{enumerate}
    \end{definition}

    As noted in the example game from section~\ref{sec:introduction}, reproduced below, it looks like we could just pivot player $A$ and $C$ down into line with the others. The ordering $ECBADF$, for example, puts every player on a straight line and satisfies everyone's contraints. Given a solution, can we always make a new solution with all players on a line?

    \begin{center} %6 player example game
        \begin{multicols}{2}
            \begin{pspicture}(0,0)(10,10)
                \qdisk(0,1){2pt}
                \uput[u](0,1){C}

                \qdisk(-0.4,2){2pt}
                \uput[u](-0.4,2){E}

                \qdisk(1,2){2pt}
                \uput[u](1,2){B}

                \qdisk(2,3){2pt}
                \uput[u](2,3){A}

                \qdisk(2.4,2){2pt}
                \uput[u](2.4,2){D}

                \qdisk(3.5,2){2pt}
                \uput[u](3.5,2){F}
            \end{pspicture}

            \columnbreak

            \begin{tabular}{l | c | c}
                $p$ & $\w(p)$ & $\n(p)$ \\
                \hline
                A &  B& C\\
                B &  D& F\\
                C &  B& A\\
                D &  B& E\\
                E &  D& F\\
                F &  D& B
            \end{tabular}
         \end{multicols}
    \end{center}

    It seems as though the extra freedom in higher dimensions might allow solutions to games that are unsolvable on the real line. A camp counselor might be tempted to have campers climb trees or stand on one another's shoulders in search of a solution. Perhaps surprisingly, this is unnecessary. Any game that is solvable in $\mathbb{R}^n$ is solvable in $\mathbb{R}$.

	\vspace{12pt}
    \begin{thm}
    Any Ninja Assassin Wonderwall game which has a solution in $n$ dimensions ($n > 1$) has a solution in $n-1$ dimensions.
    \end{thm}
    \begin{proof}
    Suppose we have a game that has a solution in $\mathbb{R}^n$. That is, we have a one-to-one function $S: P \to \mathbb{R}^n$ such that for each $p \in P$, $p$'s wonderwall lies on the line segment between $p$'s ninja assassin and $p$. 

    Consider the set $L$ of all lines in $\mathbb{R}^n$ which go through two or more points in the image of $P$ under $S$. Since there are $\lvert P \rvert$ points, there are no more than $\binom{ \lvert P \rvert}{2}$ such lines. 

    Now consider an $n-1$-dimensional hyperplane $\Pi$ through the origin that is not perpendicular to any line in $L$. Since each line is perpendicular to exactly one hyperplane, and $\lvert L \rvert \leq \binom{\lvert P \rvert}{2}$, which is finite, such a hyperplane exists. (There are uncountably many $(n-1)$-dimensional hyperplanes through the origin).

    Form a new solution, $S'$ by mapping each player $p\in P$ to the projection onto $\Pi$. By construction, $\Pi$ is not perpendicular to any line in $L$, so each player's position is distinct. Since projection onto a plane through the origin is a linear transformation, linear relationships are preserved. In particular, the linear relationships which put every player's wonderwall on the line segment between that player and their ninja assassin. So $S'$ is a solution in $n-1$ dimensions.
    \end{proof}
    \begin{center}
    \begin{tabular}{r c l}
    {%
    \begin{pspicture}(0,0)(10,10)
        %Future locations
        %(included to maintain scale with other picture)
        %(plotted in white, to be covered over)
        \uput[d](0,0){\color{white}{C}}
        \uput[d](-0.4,0){\color{white}{E}}
        \uput[d](1,0){\color{white}{B}}
        \uput[d](2,0){\color{white}{A}}
        \uput[d](2.4,0){\color{white}{D}}
        \uput[d](3.5,0){\color{white}{F}}  


        %players and labels
        \qdisk(0,1){2pt}
        \uput[u](0,1){C}

        \qdisk(-0.4,2){2pt}
        \uput[u](-0.4,2){E}

        \qdisk(1,2){2pt}
        \uput[u](1,2){B}

        \qdisk(2,3){2pt}
        \uput[u](2,3){A}

        \qdisk(2.4,2){2pt}
        \uput[u](2.4,2){D}

        \qdisk(3.5,2){2pt}
        \uput[u](3.5,2){F}

        %the set L
        \psline[linestyle=dotted](-0.5,0.5)(2.5,3.5) %CBA
        \psline[linestyle=dotted](-1,2)(4,2) %EBDF

        \psline[linestyle=dotted](1.7,3.75)(2.7,1.25) %AD
        \psline[linestyle=dotted](1.6,3.26666)(3.9,1.7333) %AF
        \psline[linestyle=dotted](-1,1.75)(2.6,3.25) %AE

        \psline[linestyle=dotted](-0.6,2.5)(0.2,0.5) %CE
        \psline[linestyle=dotted](-0.5,0.79166)(3.3,2.375) %CD
        \psline[linestyle=dotted](-0.4,0.8857)(3.9,2.11428) %CF

        %hyperplane Pi
        \psline(-1,0)(4,0)
        \uput[r](4,0){$\Pi$}
    \end{pspicture}} & {%
    \color{white}{project}
    } &{%
    \begin{pspicture}(0,0)(10,10)

        %old locations
        \pscircle[linestyle=dashed](0,1){3pt}
        \uput[u](0,1){C}

        \pscircle[linestyle=dashed](-0.4,2){3pt}
        \uput[u](-0.4,2){E}

        \pscircle[linestyle=dashed](1,2){3pt}
        \uput[u](1,2){B}

        \pscircle[linestyle=dashed](2,3){3pt}
        \uput[u](2,3){A}

        \pscircle[linestyle=dashed](2.4,2){3pt}
        \uput[u](2.4,2){D}

        \pscircle[linestyle=dashed](3.5,2){3pt}
        \uput[u](3.5,2){F}
        
        %lines of projection
        \psline[linestyle=dashed](-0.4,2)(-0.4,0) %E
        \psline[linestyle=dashed](0,1)(0,0) %C
        \psline[linestyle=dashed](1,2)(1,0) %B
        \psline[linestyle=dashed](2,3)(2,0) %A
        \psline[linestyle=dashed](2.4,2)(2.4,0) %D
        \psline[linestyle=dashed](3.5,2)(3.5,0) %F

        %players and labels
        \qdisk(0,0){2pt}
        \uput[d](0,0){C}

        \qdisk(-0.4,0){2pt}
        \uput[d](-0.4,0){E}

        \qdisk(1,0){2pt}
        \uput[d](1,0){B}

        \qdisk(2,0){2pt}
        \uput[d](2,0){A}

        \qdisk(2.4,0){2pt}
        \uput[d](2.4,0){D}

        \qdisk(3.5,0){2pt}
        \uput[d](3.5,0){F}        


        %hyperplane Pi
        \psline(-1,0)(4,0)
        \uput[r](4,0){$\Pi$}
    \end{pspicture}}
    \end{tabular}
    \emph{Notice that hyperplane $\Pi$ is not perpendicular to any line connecting two or more players. This means that $S'$, the projection of the players' positions onto $\Pi$, maps each player to a distinct position.}
    \end{center}

    This theorem, repeated as necessary, shows that if a solution exists in $n>1$ dimensions, a solution exists in one dimension. Thus, if we are looking for solutions, it is enough to consider orderings of players on a line.

\section{Algorithms}
\subsection{Relation to CNF-Sat}
\label{sec:cnf_sat}
    A simple, though possibly inefficient, way to solve a Ninja Assassin Wonderwall problem would be to transform it into an instance of a known problem for which solvers already exist. We will transform an arbitrary Ninja Assassin Wonderwall problem into a Conjunctive Normal Form Satisfiability (CNF SAT) problem.

    Conjunctive Normal Form Satisfiability, or CNF Sat, is a problem whose input is a statement in propositional logic of the form
        \begin{align*} 
                    & (a_1 \vee a_2 \vee \ldots \vee a_{n_a}) \\
            \wedge  & (b_1 \vee b_2 \vee \ldots \vee b_{n_b})\\
            \vdots  &\\
            \wedge  & (x_1 \vee x_2 \vee \ldots \vee x_{n_x})
        \end{align*}
    and whose output is a mapping from each variable in the statement to either true or false such that the statement as a whole is true. 

    We begin with some notation. Let $x_{a,b}$ denote the truth of `player $a$ is left of player $b$'. Also, note that $x_{a,b} = \lnot x_{b,a}$, so we have $\binom{n}{2}$ variables. Then for each row of a relationship table $p$, $\w(p)$, $\n(p)$, we can write
        \begin{align*}
                    & (x_{p_1, \w(p_1)} \Leftrightarrow x_{\w(p_1), \n(p_1)})\\
            \wedge  & (x_{p_2, \w(p_2)} \Leftrightarrow x_{\w(p_2), \n(p_2)})\\
            \vdots  &\\
            \wedge  & (x_{p_n, \w(p_n)} \Leftrightarrow x_{\w(p_n), \n(p_n)})
        \end{align*}

    In order to put our statement in CNF, we will need to convert each of those clauses. For player $i$, we will have 
        \begin{align*}
            & (x_{p_i, \w(p_i)} \Leftrightarrow x_{\w(p_i), \n(p_i)})\\
            \Leftrightarrow & (\lnot x_{p_i, \w(p_i)} \vee x_{\w(p_i), \n(p_i)}) \wedge (x_{p_i, \w(p_i)} \vee \lnot x_{\w(p_i), \n(p_i)})
        \end{align*}

    What we haven't mentioned yet is that there is a big difference between a CNF SAT problem with two variables to a clause (2-SAT), and one with three variables to a clause (3-SAT). Surprisingly, 2-SAT can be solved in linear time but 3-SAT is an NP-Complete problem~\cite{clrs}(pg 1049). That is, no one has found an algorithm that will solve it in polynomial time (and the general sentiment is that none exists).

    So far, so good: we only have two variables to a clause. This looks like it is leading us to a linear time solution. (Actually, since our variables are $x_{p_i, p_j}$, this would be an $O(n^2)$ solution). 

    However, this is not quite enough. In moving to simple boolean values, we have given up the transitive property. As it is now, there is nothing keeping the problem from deciding that $x_{a,b}, x_{b,c}$, and $x_{c,a}$ are all true (even though this wouldn't make sense in the context of a linear solution). One way to think about this is that a solution to the Ninja Assassin Wonderwall problem will always produce a solution to the CNF SAT problem, but not the other way around.

    We will need to add constraints to ensure that we respect transitivity. For every $a,b,c \in P$, we need the condition $(x_{a,b} \wedge x_{b,c}) \Rightarrow x_{a,c}$. This adds quite a bit of bloat to our statement. Specifically, it adds $n(n-1)(n-2)$ expressions of that form, all $\wedge$'d together.

    More important than just increasing the size of our statement, each of these new clauses will contain three variables:
    \begin{align*}
        &(x_{a,b} \wedge x_{b,c}) \Rightarrow x_{a,c} \\
        \Leftrightarrow & (\lnot x_{a,b} \vee \lnot x_{b,c} \vee x_{a,c})
    \end{align*}

    This pushes us squarely into the realm of 3-SAT, where we don't expect to find a polynomial time algorithm to save us. 
    
    To sum up the problem, we have a number of clauses all $\wedge$'d together. For every player $p_i \in P$, we have:
\[
	(\lnot x_{p_i, \w(p_i)} \vee x_{\w(p_i), \n(p_i)}) \wedge (x_{p_i, \w(p_i)} \vee \lnot x_{\w(p_i), \n(p_i)})
\]
	And for every $a,b,c \in P$, 
\[
	\lnot x_{a,b} \vee \lnot x_{b,c} \vee x_{a,c}
\]
	\vspace{12pt}
	\begin{thm} A solution to this CNF problem gives a solution to the Ninja Assassin Wonderwall problem. 
	\end{thm}
    \begin{proof}
    Suppose we have solution to this CNF problem. That is, we have a mapping from $\{x_{a,b} \mid a,b \in P\}$ into $\{\const{true}, \const{false}\}$. We claim that the values of $x_{a,b}$ give rise to a strict total order relation, $<$, where $a<b$ if and only if $x_{a,b}$ is true. To be a total order, $<$ must be defined for all $a,b \in P$, which we have because either $x_{a,b}$ or $x_{b,a}$ is defined by the solution to the CNF problem (we take $x_{a,a}$ to be always \const{false}). We also need transitivity, but this is exactly what the second set of constraints is designed to give us.

    Let $\{p_i\}$ be the permutation of $P$ that comes from sorting according to this total order. Define $\phi: P \to \mathbb{R}$ by $\phi(p_i) = i$. Each player is taken to its unique index, so $\phi$ is one-to-one. The first set of constraints to the CNF problem ensure that the permutation $\{p_i\}$ satisfies each player's constraints. Since $\phi(P)$ are all on the real line in the same order as in the sequence $\{p_i\}$, $\phi$ also satisfies each player's constraints. So $\phi$ is a solution to the Ninja Assassin Wonderwall problem.
    
    \end{proof}

    So this is a possible way to solve Ninja Assassin Wonderwall problems. Another option would be to stop with the 2-SAT problem created by ignoring transitivity constraints. From there, we could enumerate all solutions, searching for one that respected transitivity. %I've downloaded an article with an algorithm describing the enumeration step of this, but I haven't had a chance to play with it. Probably won't before I turn this in...

\subsection{Constructive algorithm}
    \label{sec:algorithm}
    Consider a permutation $\sigma$ of the player set $P$. We'd like to know if $\sigma$ is a solution. If that $\sigma$ satisfies player $p$'s constraints, then $\sigma$ must have $\w(p)$ between $p$ and $\n(p)$. That is, either $p$ is to the left of $\w(p)$ is to the left of $\n(p)$ or else the reverse is true. We can construct a directed graph $G=(P,E)$, where we interpret an edge $(a,b) \in E$ to represent the statement `player $a$ is to the left of player $b$ in an ordering of players'. 

    This says, transitively, that if there is a path from $a$ to $b$, then $a$ is to the left of $b$ (we will use $a \leadsto b$ to denote both of these). Notice that if these graphs actually represent an ordering of players, they do not contain cycles. For example, when both $(a,b)$ and $(b,a)$ are in $E$, this says $a \leadsto b$ and $b \leadsto a$, which is a contradiction. So we know we are looking for a graph with no cycles -- a directed acyclic graph, or DAG.

    \begin{thm}
    A Ninja Assassin Wonderwall problem has a solution iff there is a directed acyclic graph $G=(P,E)$ such that, for all $p\in P$, either  $p \leadsto \w(p) \leadsto \n(p)$ or $\n(p) \leadsto \w(p) \leadsto p$.
    \end{thm}
    \begin{proof} \mbox{}

    \begin{description}
    \item[$(\Rightarrow)$] Let $\phi: P \to \mathbb{R}$ be a solution to a Ninja Assassin Wonderwall problem. Construct a graph $G$ with an edge $(p,q)$ whenever $\phi(p)<\phi(q)$. By construction, $G$ is acyclic (in fact it is an ordered graph).

    Consider an arbitrary player $p$. Since $\phi$ is a solution, $\phi(\w(p))$ must be between $\phi(p)$ and $\phi(\n(p))$. So either $\phi(p) < \phi(\w(p)) < \phi(\n(p))$ or $\phi(\n(p)) < \phi(\w(p)) < \phi(p)$. Then either $p \leadsto \w(p) \leadsto \n(p)$ or $\n(p) \leadsto \w(p) \leadsto p$.

    \item[$(\Leftarrow)$] Let $G$ be such a graph. Let $\{p_i\}$ be a topological ordering of $G$. Define $\phi(p_i) = i$. 

    Let $p_i$ be an arbitrary player. By assumption, either $p_i \leadsto \w(p_i) \leadsto \n(p_i)$ or $\n(p_i) \leadsto \w(p_i) \leadsto p_i$. Without loss of generality, $p_i \leadsto \w(p_i) \leadsto \n(p_i)$. Since $\{p_i\}$ is a topological sort on $G$, $p_i$ must come before $\w(p_i)$, which must come before $\n(p_i)$. So $\phi(p_i) < \phi(\w(p_i)) < \phi(\n(p_i))$. Thus, $\phi$ is a solution to a Ninja Assassin Wonderwall problem.
    \end{description}
    \end{proof}

    This proof leads to an algorithm for constructing solutions. Consider the set $D$ of all digraphs $G=(P,E)$, where $E$ is constructed by taking, for all $p \in P$, either  $(p,\w(p)), (\w(p),\n(p))$ or $(\n(p),\w(p)),(\w(p),p)$. There are $2^n$ such graphs, and if a NAWW problem has a solution, one of them must be acyclic. Furthermore, the solution will be given by a Topological Sort of that graph. (A Topological Sort on a directed acyclic graph is an ordering that puts vertex $a$ before every vertex to which $a$ has outgoing edges.)

    Pseudocode for this algorithm, and the more efficienct versions described below, can be found in the appendix, section~\ref{sec:appendix_pseudocode}.
 
    There are many small efficiencies we can add to this algorithm. We can avoid enumerating all the elements of $D$ by trying to construct our graph from scratch. We will start with an empty graph $G$. Then we will choose a $p \in P$, add the edges $(p,\w(p))$ and $(\w(p),\n(p))$ and recurse. If this leads to a cyclic graph, we will try the opposite edges and recurse. If \emph{this} leads to a cyclic graph, then neither $p \leadsto \w(p) \leadsto \n(p)$ nor $\n(p) \leadsto \w(p) \leadsto p$ is consistent with the graph, and so there is no solution.

    We can make another small improvement by noticing that if $a \leadsto b$ where $a,b \in \{p, \w(p), \n(p)\}$ for some $p$, is already in the graph, then we can add the third element of $\{p, \w(p), \n(p)\}$ immediately. For example if $p \leadsto \n(p)$, then if $G$ is a subgraph of the acyclic graph in the theorem, $p \leadsto \w(p)$ and $\w(p) \leadsto \n(p)$. Edges that we can infer in this way are called \emph{implied edges}.

    Finally, notice that every \emph{implied edge} we add potentially cuts our running time in half. We no longer need a tree of $2^{\lvert S \rvert}$ recursive calls to determine the direction of that player's constraint. Each edge we add that has an \emph{implied edge} gives us some extra leverage over the problem. Heuristically, it seems like we should exert this leverage as early as possible. We accomplish this by choosing our $p\in S$ at the start of each recursive call such that the set $\{p,\w(p), \n(p)\}$ shares two elements with as many $\{t, \w(t), \n(t)\}, t\in S$ as possible. 

    %In fact, we get the first choice we make for free. Since for any solution, the reverse of that permutation is also a solution, it doesn't matter which way we direct the edges of the first player we consider.

\subsection{Example trace of algorithm}
\label{sec:alg-example}
    We will walk through the logic of the algorithm for a small game:

    \begin{center}
        \begin{tabular}{ l | c | c}
         $p$ & $\w(p)$ & $\n(p)$ \\
         \hline
          A &  E& C\\
          B &  E& D\\
          C &  D& E\\
          D &  E& B\\
          E &  D& C\\
          F &  B& A
        \end{tabular} %assume D->E, assume A->B.
    \end{center}
    \begin{comment}
        Assume E -> D
          E -> D is given, so player B's choices give B -> D
          E -> D is given, so player B's choices give B -> E
          E -> D is given, so player C's choices give E -> C
          E -> D is given, so player C's choices give D -> C
          E -> D is given, so player D's choices give B -> D
          E -> D is given, so player D's choices give B -> E
          E -> D is given, so player E's choices give E -> C
          E -> D is given, so player E's choices give D -> C
          D -> C is given, so player C's choices give E -> C
          D -> C is given, so player C's choices give E -> D
          D -> C is given, so player E's choices give E -> C
          D -> C is given, so player E's choices give E -> D
          E -> C is given, so player A's choices give A -> C
          E -> C is given, so player A's choices give A -> E
          E -> C is given, so player E's choices give D -> C
          E -> C is given, so player E's choices give E -> D
          D -> C is given, so player E's choices give E -> C
          D -> C is given, so player E's choices give E -> D
          Assume F -> B
            F -> B is given, so player F's choices give F -> A
            F -> B is given, so player F's choices give B -> A
            No more players to try, and G is acyclic: Success!
         F B A E D C
    \end{comment}
    To start, we will direct some triplet. As we've noted, we will achieve a faster runtime if we choose a triplet containing a most common pair. A listing of each pair and the number of times it occurs in one of the triplets is given below.
    \begin{center}
    \begin{tabular}{l | c}
        Pair & count \\
        \hline
        D,E & 4 \\
        C,E & 3 \\
        C,D & 2 \\
        B,E & 2 \\
        B,D & 2 \\
        A,F & 1 \\
        A,E & 1 \\
        A,B & 1 \\
        B,F & 1 \\
        A,C & 1 
    \end{tabular}
    \end{center}

    So we want to direct $p\leadsto \w(p) \leadsto \n(p)$ for some triplet $(p, \w(p), \n(p))$ where $D$ and $E$ appear in the triplet. Let's choose $B \leadsto E \leadsto D$.
    \begin{center}
    %created with echo "digraph G{ rankdir=LR; B->E->D; }" | dot2tex --prog=dot --codeonly
    % Start of code
        % \begin{tikzpicture}[anchor=mid,>=latex',line join=bevel,]
        \begin{tikzpicture}[>=latex',line join=bevel,]
          \pgfsetlinewidth{1bp}
        %%
        \pgfsetcolor{black}
          % Edge: E -> D
          \draw [->] (144.4bp,18bp) .. controls (152.39bp,18bp) and (161.31bp,18bp)  .. (179.92bp,18bp);
          % Edge: B -> E
          \draw [->] (54.403bp,18bp) .. controls (62.393bp,18bp) and (71.311bp,18bp)  .. (89.919bp,18bp);
          % Node: B
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (27bp,18bp) ellipse (27bp and 18bp);
          \draw (27bp,18bp) node {B};
        \end{scope}
          % Node: E
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (117bp,18bp) ellipse (27bp and 18bp);
          \draw (117bp,18bp) node {E};
        \end{scope}
          % Node: D
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (207bp,18bp) ellipse (27bp and 18bp);
          \draw (207bp,18bp) node {D};
        \end{scope}
        %
        \end{tikzpicture}
    % End of code
    \end{center}

    Since we're now operating under the assumption that $B \leadsto E \leadsto D$, we can infer a few edges:
    \begin{itemize}
        \item We know that $E \leadsto D$, so player $B$'s choices of $(B,E,D)$ give $B\leadsto D$.
        \item We know that $E \leadsto D$, so player $C$'s choices of $(C,D,E)$ give $E\leadsto C$.
        \item We know that $E \leadsto D$, so player $C$'s choices of $(C,D,E)$ give $D\leadsto C$.
    \end{itemize}
    We could also have used players $D$ and $E$, instead of $B$ and $C$, to infer these same edges so we should evict them from the set $S$ of as-yet-unconsidered players. The new edges change the graph:
    %echo "digraph G{ rankdir=LR; B->E->D; B->D; E->C; D->C; }" | dot2tex --prog=dot --figonly
    \begin{center}
    \begin{tikzpicture}[>=latex,line join=bevel,]
        \pgfsetlinewidth{1bp}
        %%
        \pgfsetcolor{black}
          % Edge: E -> D
          \draw [->] (138.85bp,28.901bp) .. controls (150.03bp,34.745bp) and (164bp,42.044bp)  .. (185.29bp,53.177bp);
          % Edge: E -> C
          \draw [->] (143.88bp,21.344bp) .. controls (174.55bp,25.308bp) and (225.83bp,31.933bp)  .. (270.37bp,37.689bp);
          % Edge: D -> C
          \draw [->] (232.51bp,57.593bp) .. controls (241.57bp,55.226bp) and (252.01bp,52.497bp)  .. (271.62bp,47.372bp);
          % Edge: B -> E
          \draw [->] (52.513bp,34.593bp) .. controls (61.572bp,32.226bp) and (72.012bp,29.497bp)  .. (91.619bp,24.372bp);
          % Edge: B -> D
          \draw [->] (53.883bp,44.344bp) .. controls (84.554bp,48.308bp) and (135.83bp,54.933bp)  .. (180.37bp,60.689bp);
          % Node: C
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (297bp,41bp) ellipse (27bp and 18bp);
          \draw (297bp,41bp) node {C};
        \end{scope}
          % Node: B
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (27bp,41bp) ellipse (27bp and 18bp);
          \draw (27bp,41bp) node {B};
        \end{scope}
          % Node: E
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (117bp,18bp) ellipse (27bp and 18bp);
          \draw (117bp,18bp) node {E};
        \end{scope}
          % Node: D
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (207bp,64bp) ellipse (27bp and 18bp);
          \draw (207bp,64bp) node {D};
        \end{scope}
        %
    \end{tikzpicture}
    \end{center}
    One of these new edges, $E \leadsto C$ gives rise to two more implied edges:

    \begin{itemize}
        \item We know that $E \leadsto C$, so player $A$'s choices of $(A,E,C)$ give $A\leadsto C$.
        \item We know that $E \leadsto C$, so player $A$'s choices of $(A,E,C)$ give $A\leadsto E$
    \end{itemize}

    This leaves us with the following graph.
    %echo "digraph G{ rankdir=LR; B->E->D; B->D; E->C; D->C; A->C; A->E; }" | dot2tex --prog=dot --figonly
    \begin{center}
        \begin{tikzpicture}[>=latex,line join=bevel,]
          \pgfsetlinewidth{1bp}
        %%
        \pgfsetcolor{black}
          % Edge: E -> D
          \draw [->] (139.3bp,55.167bp) .. controls (150.14bp,60.339bp) and (163.51bp,66.719bp)  .. (184.59bp,76.781bp);
          % Edge: B -> E
          \draw [->] (50.662bp,71.729bp) .. controls (60.824bp,67.572bp) and (72.99bp,62.595bp)  .. (93.415bp,54.239bp);
          % Edge: A -> E
          \draw [->] (52.046bp,25.378bp) .. controls (61.435bp,28.259bp) and (72.362bp,31.611bp)  .. (92.287bp,37.725bp);
          % Edge: E -> C
          \draw [->] (144.26bp,44.41bp) .. controls (174.85bp,43.722bp) and (225.55bp,42.583bp)  .. (269.92bp,41.586bp);
          % Edge: D -> C
          \draw [->] (228.85bp,76.099bp) .. controls (240.03bp,70.255bp) and (254bp,62.956bp)  .. (275.29bp,51.823bp);
          % Edge: A -> C
          \draw [->] (54.302bp,16.877bp) .. controls (77.841bp,16.14bp) and (113.27bp,15.689bp)  .. (144bp,18bp) .. controls (184.23bp,21.027bp) and (229.96bp,28.499bp)  .. (270.85bp,36.009bp);
          % Edge: B -> D
          \draw [->] (54.265bp,81.885bp) .. controls (84.851bp,82.916bp) and (135.55bp,84.625bp)  .. (179.92bp,86.121bp);
          % Node: A
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (27bp,18bp) ellipse (27bp and 18bp);
          \draw (27bp,18bp) node {A};
        \end{scope}
          % Node: C
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (297bp,41bp) ellipse (27bp and 18bp);
          \draw (297bp,41bp) node {C};
        \end{scope}
          % Node: B
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (27bp,81bp) ellipse (27bp and 18bp);
          \draw (27bp,81bp) node {B};
        \end{scope}
          % Node: E
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (117bp,45bp) ellipse (27bp and 18bp);
          \draw (117bp,45bp) node {E};
        \end{scope}
          % Node: D
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (207bp,87bp) ellipse (27bp and 18bp);
          \draw (207bp,87bp) node {D};
        \end{scope}
        %
        \end{tikzpicture}
    \end{center}

    All that from one assumption! This graph is still acyclic, which is good, but we haven't included every player's constraints yet. So far, we've considered players $A,B,C,D$, and $E$. So $S=\{F\}$, and we will further assume $F\leadsto B \leadsto A$. This empties $S$ and gives us the graph below, which is acyclic! 

    %echo "digraph G{ nodesep=0.15; ranksep=0.25; rankdir=LR; B->E->D; B->D; E->C; D->C; A->C; A->E; F->B->A;}" | dot2tex --prog=dot --figonly
    \begin{center} 
        \begin{tikzpicture}[>=latex,line join=bevel,]
          \pgfsetlinewidth{1bp}
        %%
        \pgfsetcolor{black}
          % Edge: F -> B
          \draw [->] (54.065bp,53bp) .. controls (56.492bp,53bp) and (58.981bp,53bp)  .. (71.679bp,53bp);
          % Edge: E -> D
          \draw [->] (266.53bp,56.335bp) .. controls (271.53bp,58.405bp) and (276.92bp,60.636bp)  .. (291.51bp,66.682bp);
          % Edge: B -> E
          \draw [->] (126.04bp,51.9bp) .. controls (148.32bp,50.958bp) and (180.63bp,49.593bp)  .. (215.64bp,48.114bp);
          % Edge: B -> A
          \draw [->] (121bp,42.499bp) .. controls (126.95bp,39.523bp) and (133.55bp,36.223bp)  .. (149.01bp,28.494bp);
          % Edge: A -> E
          \draw [->] (194.53bp,27.335bp) .. controls (199.53bp,29.405bp) and (204.92bp,31.636bp)  .. (219.51bp,37.682bp);
          % Edge: E -> C
          \draw [->] (270.04bp,45.9bp) .. controls (292.32bp,44.958bp) and (324.63bp,43.593bp)  .. (359.64bp,42.114bp);
          % Edge: D -> C
          \draw [->] (337bp,65.499bp) .. controls (342.95bp,62.523bp) and (349.55bp,59.223bp)  .. (365.01bp,51.494bp);
          % Edge: A -> C
          \draw [->] (198.26bp,18.606bp) .. controls (218.03bp,19.24bp) and (245.77bp,20.508bp)  .. (270bp,23bp) .. controls (297.25bp,25.802bp) and (327.86bp,30.624bp)  .. (360.75bp,36.314bp);
          % Edge: B -> D
          \draw [->] (125.25bp,57.686bp) .. controls (148.68bp,61.852bp) and (184.58bp,67.769bp)  .. (216bp,71bp) .. controls (236.35bp,73.093bp) and (259.18bp,74.322bp)  .. (287.74bp,75.394bp);
          % Node: A
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (171bp,18bp) ellipse (27bp and 18bp);
          \draw (171bp,18bp) node {A};
        \end{scope}
          % Node: C
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (387bp,41bp) ellipse (27bp and 18bp);
          \draw (387bp,41bp) node {C};
        \end{scope}
          % Node: B
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (99bp,53bp) ellipse (27bp and 18bp);
          \draw (99bp,53bp) node {B};
        \end{scope}
          % Node: E
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (243bp,47bp) ellipse (27bp and 18bp);
          \draw (243bp,47bp) node {E};
        \end{scope}
          % Node: D
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (315bp,76bp) ellipse (27bp and 18bp);
          \draw (315bp,76bp) node {D};
        \end{scope}
          % Node: F
        \begin{scope}
          \definecolor{strokecol}{rgb}{0.0,0.0,0.0};
          \pgfsetstrokecolor{strokecol}
          \draw (27bp,53bp) ellipse (27bp and 18bp);
          \draw (27bp,53bp) node {F};
        \end{scope}
        %
        \end{tikzpicture}

    \end{center}

    A topological sort of this graph gives $\langle F, B, A, E, D, C \rangle$, which is a valid solution to the Ninja Assassin Wonderwall problem. 

    An example of a game without a solution is given in the next section.

\subsection{Running time of algorithm}
\label{sec:run-time}
    Let $D$ be the set of all digraphs whose edgesets are constructed by taking either $p \leadsto \w(p) \leadsto \n(p)$ or the reverse for every $p\in P$. The first algorithm described examines each digraph $G$ in $D$, checking each to see if it is acyclic. Since the check for acyclic takes $O(n)$ time where $n$ is the number of players~\cite{clrs}(pg 606), the whole algorithm takes $O(\lvert D \rvert \cdot n)$ time. 

    So what is $\lvert D \rvert$? We're constructing the edgeset by taking each row $(p, \w(p), \n(p))$ and directing it to the left or to the right. So an element of $D$ for a particular relationship table is uniquely identified by a bitstring of length $n$, $01011\ldots$, where a $0$ in the $i^{\text{th}}$ row indicates direction to left and a $1$ indicates direction to the right. There are $2^n$ such bitstrings, so $\lvert D \rvert = 2^n$. This first algorithm then, takes $O(n \cdot 2^n)$ time in the worst case. 

    It is not immediately clear what the running time of the heuristic algorithm is. The average case running time would be very hard to determine, as the heuristic muddies the water a fair bit. However, we will see that the worst case running time remains exponential.

    We will set a ``trap'' for the algorithm. Specifically, we construct a class of problem designed to afford no leverage to the heuristic. We seek to confound the main improvement of the heuristic algorithm: extrapolating extra edge information each time it directs a pair. 

    The following is a template for a relationship table, where we would want to replace each of $a, b, c, \text{ and }d$ with actual player names.

    \begin{center}
        \begin{tabular}{c | c | c}
            $p$ & $\w(p)$ & $\n(p)$\\
            \hline
            $a$ & $b$ & $c$\\
            $b$ & $c$ & $d$\\
            $c$ & $b$ & $a$\\
            $d$ & \_ & \_
        \end{tabular}
    \end{center}

    We could repeat this pattern indefinitely, making an arbitrarily large game. The very last instance of the template would replace $d \quad \_ \quad \_$ with $d \quad a \quad b$, ensuring a contradiction within that group. For example, here is a game with three copies of that structure:

    \begin{center}
        \begin{tabular}{c | c | c}
            $p$ & $\w(p)$ & $\n(p)$\\
            \hline
            $A$ & $B$ & $C$\\
            $B$ & $C$ & $D$\\
            $C$ & $B$ & $A$\\
            \hline
            $D$ & $E$ & $F$\\
            $E$ & $F$ & $G$\\
            $F$ & $E$ & $D$\\
            \hline
            $G$ & $H$ & $I$\\
            $H$ & $I$ & $J$\\
            $I$ & $H$ & $G$\\
            $J$ & $G$ & $H$
        \end{tabular}
    \end{center}

    Notice how each group of four players is `self-contained'. The choices of players $A,B,C$ contain no player other than $A,B,C, \text{ and } D$; the choices of players $D, E, F$ contain no player other than $D, E, F, \text{ and } G$. The overlap is just enough so that the games are not disjoint. This means that any leverage gained via the heuristic will not escape the four player group.

    For example, if the algorithm assumes that $A \leadsto D$, this information is useless as soon as we're addressing players other than $A,B,C,D$.

    This demonstrates the fact that the algorithm will have to backtrack and reverse each assumption it makes upon reaching the cycle at the end. Since it will make one assumption for each group of three players, the running time will be $O(n \cdot 2^{n/3})$, which is exponential. 

    This is a worst case analysis, and in practice the running times are often much better than this. We have presented a pathological case in order to show that this algorithm has not beaten the exponential bound.

\begin{comment}
\section{Overview: Steiner Triple Systems}
    Definition, examples
    discuss how the number of pairs dominates the number of players
    (this defeats our heuristic)
    A slightly better algorithm could `outsmart' our trap from the previous section, but the existence of Steiner Triple Systems shows that we can have so few repeated pairs as to render the heuristic useless. STS shows that this is a systemic problem. 
\end{comment}

\section{Proportion of solvable games}
    \label{sec:prob}
    We are curious about, for a fixed $n$, what proportion of Ninja Assassin Wonderwall games have a solution. 

    First, how many games exist of a given size? A game depends on the independent choices of all $n$ players. Each player chooses a wonderwall and a ninja assassin from the other $n-1$ players. This means each player has $n(n-1)$ ways to assign these roles. So the total number of games is $\displaystyle \left(n(n-1)\right)^n$. This grows almost unimaginably quickly, as illustrated in the table below. The number of non-isomorphic games is smaller, of course, but I have not found a way to enumerate non-isomorphic games. One of the difficulties is described in Section~\ref{sec:future-work}.
    \begin{center}
        \begin{tabular}{c | r}
        $n$ & $\displaystyle \left(n(n-1)\right)^n$\\
        \hline
        3 & 8\\
        4 & 1296 \\
        5 & 248832 \\
        6 & 64000000\\
        $\vdots$ & $\vdots$ \\
        10 & 3743906242624487424
        \end{tabular}
    \end{center}
    This probably too many to enumerate for anything over $n=6$, so we will approximate the proportion with a random sample. Even so, we've seen that our algorithm is $O(n\cdot 2^n)$, if only in pathological cases. Running, say, 10000 trials for a number of different sizes of game would take a long time.

    We can cheat a bit using distributed computing. I randomly drew a 10000 game sample for each size from 4 to 100, putting them all in a job queue. I wrote a python script to pull problems out of the queue and pass them to a C++ implementation of the algorithm described in section \ref{sec:algorithm}. The result -- solvable or not -- was pushed to a central server. 

    I spun up this python script on about 130 computers, with between 8-24 threads each, and obtained the results below. I was doing this over spring break, when the computers were mostly not in use.

    \begin{center}
    \includegraphics[width=0.8\textwidth]{probplot.png}
    \end{center}

    It seems that the likelihood that a game has a solution increases very quickly with the number of players.

    We didn't get quite all the way to $n=100$. Around $n=90$ the processes start to really drag. Also, spring break had ended and I needed to give back some computing resources. I received a message from Matthew Mooney, a student in the Computer Science department:
    \begin{quote}
    Hey, did you know you have a process running on cf416-14 that's using 99\% of the CPU? Not a big deal as I can just switch PCs, but thought you might want to know.
    \end{quote}
    And then, a few minutes later:
    \begin{quote}
    k I take that back. On my end at least, it looks like that process is running on multiple computers (maybe all? I've checked 3). Any idea what's up?
    \end{quote}

    It seemed polite to stop the simulation at this point.

\section{Future work}
    \label{sec:future-work}
    We have danced around the question of NP-Completeness in this paper. It would be good to determine whether or not Ninja Assassin Wonderwall is NP-Complete. If it is, we should provide a proof. If not, perhaps we can find a polynomial time algorithm.

    Our algorithm depends on knowing all of the relationships among the players. It would be interesting to model the way \emph{people} play the game. How can players with incomplete knowledge find solutions?

 Two Ninja Assassin Wonderwall problems $(P,w,n)$, $(P', w', n')$ are isomorphic if there is a bijection $\phi: P\to P'$ such that $w'=\phi\circ w\circ \phi^{-1}$ and $n'=\phi\circ n\circ \phi^{-1}$.  (i.e. one gets the other by ``renaming'' the players.)

    Some games are isomorphic in this way. We would like to be able to count how many non-isomorphic games exist on a given player set. It is also possible that the number of non-isomorphic games is much smaller than the number of total games. and we could have a hope of enumerating them. For example, in the tables below the roles of $B$ and $C$ have been swapped. These two games will behave identically-- if one is solvable then so is the other. A solution for one can be used to create a solution for the other just by swapping $B$ and $C$.

    \begin{center}
    \begin{multicols}{2}
        \begin{tabular}{l | c | c}
             $p$ & $\w(p)$ & $\n(p)$ \\
             \hline
             A &  C& B\\
             B &  D& A\\
             C &  D& A\\
             D &  C& E\\
             E &  A& B\\
        \end{tabular}


        \columnbreak
        \begin{tabular}{l | c | c}
             $p$ & $\w(p)$ & $\n(p)$ \\
             \hline
             A &  B& C\\
             B &  D& A\\
             C &  D& A\\
             D &  B& E\\
             E &  A& C\\
        \end{tabular}
    \end{multicols}
    \end{center}

    It would seem from this example that we could count isomorphic games on a given set of players by counting the number of bijections from $P\to P$. However, some games are unchanged under some bijections. For example, the following game does not change if we swap $D$ and $E$:

    \begin{center}
        \begin{tabular}{l | c | c}
             $p$ & $\w(p)$ & $\n(p)$ \\
             \hline
             A &  B& C\\
             B &  C& A\\
             C &  A& B\\
             D &  A& B\\
             E &  A& B\\
        \end{tabular}
    \end{center}

%\section{Conclusion}
We hope this has been enlightening for camp counselors and other outdoor educators. Counselors who are trying to keep their campers occupied now know they are better off splitting their 30-person group into two 15-person games, which are less likely to have solutions. If, instead, they're trying to bring a game to a resolution, we have provided algorithms and code to find solutions when they exist. And (perhaps to the dismay of tree-climbing, hole-digging campers), we have shown that players need not venture to three (or more!) dimensions to find solutions, but can instead keep their feet safely on the ground. 

\section{Appendix: Pseudocode}
\label{sec:appendix_pseudocode}

Pseudocode for section~\ref{sec:algorithm}. This first version takes advantage of none of the efficiencies we develop.

   \begin{codebox}
    \Procname{$\proc{FindOrdering}(P,n,w)$}
    \li \For $G\in D$
    \li     \Do
            \If $G$ is acyclic
    \li         \Do
                    \Return $\proc{TopologicalSort}(G)$
            \End
        \End
    \li \Return None
    \end{codebox}

The second version avoids enumerating all elements of $D$ by building up the graph one edge at a time.

    \begin{codebox}
    \Procname{$\proc{FindOrdering}(P,n,w)$}
    \li $G \gets (\emptyset, \emptyset)$
    \li $S \gets P$ \> \> \Comment $S$ is the set of players whose constraints have yet to be considered
    \li $G \gets \proc{MakeAssumption}(G,S,n,w)$
    \li \If $G$ is acyclic
    \li     \Do
            \Return $\proc{TopologicalSort}(G)$
        \End
    \li \Return None
    \end{codebox}


    \begin{codebox}
    \Procname{$\proc{MakeAssumption}(G,S,\n,\w)$}
    \li \If $S \isequal \emptyset$
    \li     \Then
            \Return $G$ \Comment Success!
        \End
    \li \If $G$ contains a cycle
    \li     \Then
            \Return $G$ \Comment Failure case
        \End
    \li Let $p \in S$
    \li $F \gets G$
    \li Add $(p,\w(p))$ and $(\w(p),\n(p))$ to the edgeset of $F$.
    %\li $\attrib{F}{E} \gets \attrib{F}{E} \cup \{(p,\w(p)), (\w(p),\n(p))\}$
    \li $F \gets \proc{MakeAssumption}(F,S\setminus \{p\}, \n, \w)$
    \li \If $F$ is acyclic
    \li     \Do
            \Return $F$ \Comment Success!
        \End
    \li $F \gets G$ \Comment That didn't work, try the other way.
    \li Add $(\n(p),\w(p))$ and $(\w(p),p)$ to the edgeset of $F$.
    %\li $\attrib{F}{E} \gets \attrib{F}{E} \cup \{(\n(p), \w(p)), (\w(p),p)\}$
    \li \Return $\proc{MakeAssumption}(F,S\setminus \{p\}, \n, \w)$ \Comment acyclic or not, this is our best shot.
    \end{codebox}

This last version takes advantage of the \emph{implied edges} described in section~\ref{sec:algorithm}. These implied edges speed up the runtime by moving toward either a finished graph or a contradiction with fewer recursive steps. We will use the same definition of $\proc{FindOrdering}$. It is implicit that we will choose our $p\in S$ on line~\ref{li:choose-p} of \proc{MakeAssumption} such that the set $\{p,\w(p), \n(p)\}$ shares two elements with as many $\{t, \w(t), \n(t)\}, t\in S$ as possible, in order to take advantage of \emph{implied edges} as early as possible.


    \begin{codebox}
    \Procname{$\proc{MakeAssumption}(G,S,\n,\w)$}
    \li \If $S = \emptyset$
    \li \Do \Return $G$ \Comment Success!
        \End
    \li \If $G$ contains a cycle
    \li     \Then
            \Return $G$ \Comment Failure case
        \End
    \li Let $p \in S$.              \label{li:choose-p}
    \li $F \gets G$
    \li $F \gets \proc{AddImpliedEdges}(F, (p,\w(p)), S,\n,\w)$
    \li $F \gets \proc{MakeAssumption}(F,S\setminus \{p\}, \n, \w)$
    \li \If $F$ is acyclic
    \li     \Do
            \Return $F$ \Comment Success!
        \End
    \li $F \gets G$ \Comment That didn't work, try the other way.
    \li $F \gets \proc{AddImpliedEdges}(F, (\w(p), p), S, \n, \w)$
    \li \Return $\proc{MakeAssumption}(F,S\setminus \{p\}, \n, \w)$ \Comment acyclic or not, this is our best shot.
    \end{codebox}


    \begin{codebox}
    \Procname{$\proc{AddImpliedEdges}(F,(a,b),S,\n,\w)$}
    \li $Q \gets \emptyset$
    \li $\proc{Enqueue}(Q,(a,b))$
    \li \While $Q$ is not empty
    \li     \Do
            $(r,s) \gets \proc{Dequeue}(Q)$
    \li      Add $(r,s)$ to the edgeset of $F$.
    %\li     $\attrib{F}{E} \gets \attrib{F}{E} \cup \{(r,s)\}$
    \li     \For $(t,u) \in \proc{ImpliedEdges}((r,s),S,\n,\w)$
    \li         \Do
                \If $(t,u) \notin \text{ edgeset of } F$%\attrib{F}{E}$
    \li             \Do
                    Add $(t,u)$ to the edgeset of $F$.
                    %$\attrib{F}{E} \gets \attrib{F}{E} \cup \{(t,u)\}$
    \li             $\proc{Enqueue}(Q,(t,u))$
                \End
            \End
        \End
    \li \Return $F$
    \end{codebox}



    \begin{codebox}
    \Procname{$\proc{ImpliedEdges}((r,s),S,\n,\w)$}
    \li $E \gets \emptyset$
    \li \For $t \in S$
    \li     \Do
            \If $(r,s) \isequal (t, \w(t))$
    \li         \Do
                $E \gets E \cup \{(\w(t),\n(t)), (t, \n(t))\}$
    \li     \ElseIf $(r,s) \isequal (\w(t), t)$
    \li         \Do
                $E \gets E \cup \{(\n(t),\w(t)), (\n(t), t)\}$ 
    \li     \ElseIf $(r,s) \isequal (t, \n(t))$
    \li         \Do
                $E \gets E \cup \{(t,\w(t)), (\w(t), \n(t))\}$
    \li     \ElseIf $(r,s) \isequal (\n(t), t)$
    \li         \Do
                $E \gets E \cup \{(\w(t), t), (\n(t), \w(t))\}$
    \li     \ElseIf $(r,s) \isequal (\w(t), \n(t))$
    \li         \Do
                $E \gets E \cup \{(t,\w(t)), (t, \n(t))\}$
    \li     \ElseIf $(r,s) \isequal (\n(t), \w(t))$
    \li         \Do
                $E \gets E \cup \{(\w(t), t), (\n(t), t)\}$
            \End
        \End
    \li \Return $E$
    \end{codebox}

\begin{thebibliography}{9}

\bibitem{stinson}
    Douglas R. Stinson
    \emph{Combinatorial Designs: Constructions and Analysis}.
    Springer, New York,
    2004 edition.

\bibitem{cameron}
    Peter J. Cameron
    \emph{Combinatorics: Topics, Techniques, Algorithms}.
    Cambridge University Press,
    1995 edition.

\bibitem{clrs}
    T.~H. Cormen, C.~E. Leiserson, R.~L. Rivest, and C.~Stein
    \emph{Introduction to Algorithms}.
    The MIT Press,
    2009 edition.


\end{thebibliography}

\end{document}